---
title: "Econometrics 2B: Time Series Analysis - Homework"
author: "Tim Kühleis, Bartolomeo Perazzoli"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r setup_and_data, include=FALSE}

# Setting up the Homework

# Load necessary Packages 
if (!require("pacman")) install.packages("pacman")
pacman::p_load(tidyr, fredr, dplyr, ggplot2, patchwork, urca, tseries, zoo, vars)

# Retrieve the Data from FRED using their API ----
### (You need an API Key to retrieve the Data, feel free to use mine for this "8af1b2f98eef41dfe4b5ff6ffce1bbb0")

# Define sample window
start_date <- as.Date("2000-01-01")
end_date   <- as.Date("2019-12-31")

# 1. Germany industrial activity index (monthly, Seasonally Adjusted)
industrial <- fredr(
  series_id         = "DEUPROINDMISMEI",
  observation_start = start_date,
  observation_end   = end_date,
  frequency         = "m"
)

# 2. Retrieve BAML High-Yield OAS (aggregated to monthly avg., no SA needed)
credit_spread <- fredr(
  series_id           = "BAMLHE00EHYIOAS",
  observation_start   = start_date,
  observation_end     = end_date,
  frequency            = "m",       # monthly frequency
  aggregation_method   = "avg"      # average of daily values
)

# 3. Germany CPI (monthly, again, no SA needed)
cpi <- fredr(
  series_id         = "DEUCPIALLMINMEI",
  observation_start = start_date,
  observation_end   = end_date,
  frequency         = "m"
) 

# Inspecting data briefly
head(industrial)
head(cpi)
head(credit_spread)
```

# Exercise 1

## Exercise 1.1: Plot each time-series in levels before applying any transformations

```{r exercise_1/1_plots, include=FALSE}
# Combine data into long format
data_raw <- bind_rows(
  credit_spread %>% 
    dplyr::select(date, value) %>%  # Prev. Problems with select fixed, explictly tell it to use select from dplyr
    mutate(series    = "Credit Spread",
           full_name = "ICE BofA Euro High Yield Index Option-Adjusted Spread"),
  industrial %>% 
    dplyr::select(date, value) %>% 
    mutate(series    = "Industrial Production",
           full_name = "Germany: Industrial Production Volume (Excl. Construction)"),
  cpi %>% 
    dplyr::select(date, value) %>% 
    mutate(series    = "Consumer Price Index",
           full_name = "Germany: Harmonized Consumer Price Index (HICP, All Items)")
)

# Set color palette 
series_colors <- c(
  "Credit Spread"        = "#1f77b4", # Example color (blue)
  "Industrial Production" = "#ff7f0e", # Example color (orange)
  "Consumer Price Index"  = "#2ca02c"  # Example color (green)
)
# Create a custom template for plots ----
theme_academic_individual <- function(base_size = 12) {
  theme_bw(base_size = base_size) + 
    theme(
      plot.title      = element_text(face = "bold", size = rel(1.2), hjust = 0.5),
      plot.subtitle   = element_text(size = rel(0.9), hjust = 0.5, margin = margin(b = 10)),
      axis.title.x    = element_text(size = rel(1.0), margin = margin(t = 10)),
      axis.title.y    = element_text(size = rel(1.0), margin = margin(r = 10)),
      axis.text       = element_text(size = rel(0.9)),
      panel.grid.minor= element_blank(),
      panel.grid.major= element_line(color = "grey85", linewidth = 0.4),
      plot.caption    = element_text(size = rel(0.8), hjust = 0, margin = margin(t = 10)),
      plot.margin     = margin(10, 15, 10, 10) # t, r, b, l
    )
}


# Function to create nice axisbreaks for every plot automatically ---
create_nice_breaks <- function(min_val, max_val, n = 5) {
  pretty(c(min_val, max_val), n)
}

# Create and save individual plots ----

# Plot 1: Credit Spread
data_credit <- data_raw %>% filter(series == "Credit Spread")
plot_credit_spread <- ggplot(data_credit, aes(x = date, y = value)) +
  geom_line(color = series_colors["Credit Spread"], linewidth = 0.8) +
  scale_x_date(
    date_breaks = "2 years",
    date_labels = "%Y",
    limits      = c(min(data_raw$date), max(data_raw$date)), # Consistent x-axis range
    expand      = c(0.01, 0.01)
  ) +
  scale_y_continuous(
    name   = "ICE BofA Euro High Yield Index Option-Adjusted Spread (Basis Points)",
    breaks = create_nice_breaks(min(data_credit$value), max(data_credit$value), n = 6) # More breaks
  ) +
  labs(
    title   = "Credit Spread Time Series (2000-2019)", # More focused title
    x       = "Date",
    caption = "Source: FRED (BAMLHE00EHYIOAS)"
  ) +
  theme_academic_individual()

print(plot_credit_spread)

# Save Credit Spread Plot 
ggsave("credit_spread_plot.pdf", plot_credit_spread, width = 7, height = 5)


# Plot 2: Industrial Production
data_industrial <- data_raw %>% filter(series == "Industrial Production")
plot_industrial_production <- ggplot(data_industrial, aes(x = date, y = value)) +
  geom_line(color = series_colors["Industrial Production"], linewidth = 0.8) +
  scale_x_date(
    date_breaks = "2 years",
    date_labels = "%Y",
    limits      = c(min(data_raw$date), max(data_raw$date)),
    expand      = c(0.01, 0.01)
  ) +
  scale_y_continuous(
    name   = "Germany: Industrial Production Volume (Index 2015=100)",
    breaks = create_nice_breaks(min(data_industrial$value), max(data_industrial$value), n = 6)
  ) +
  labs(
    title   = "Industrial Production Time Series (2000-2019)",
    x       = "Date",
    caption = "Source: FRED (DEUPROINDMISMEI)"
  ) +
  theme_academic_individual()

print(plot_industrial_production)

# Save Credit Spread plot 
ggsave("industrial_production_plot.pdf", plot_industrial_production, width = 7, height = 5)


# Plot 3: Consumer Price Index
data_cpi <- data_raw %>% filter(series == "Consumer Price Index")
plot_cpi <- ggplot(data_cpi, aes(x = date, y = value)) +
  geom_line(color = series_colors["Consumer Price Index"], linewidth = 0.8) +
  scale_x_date(
    date_breaks = "2 years",
    date_labels = "%Y",
    limits      = c(min(data_raw$date), max(data_raw$date)),
    expand      = c(0.01, 0.01)
  ) +
  scale_y_continuous(
    name   = "Germany: Harmonized CPI (Index 2015=100)",
    breaks = create_nice_breaks(min(data_cpi$value), max(data_cpi$value), n = 6)
  ) +
  labs(
    title   = "Consumer Price Index Time Series (2000-2019)",
    x       = "Date",
    caption = "Source: FRED (DEUCPIALLMINMEI)"
  ) +
  theme_academic_individual()

print(plot_cpi)

# Save CPI Plot 
ggsave("cpi_plot.pdf", plot_cpi, width = 7, height = 5)
```

*Comment on these plots:*
- *CPI*: Non stationary looks like a deterministic trend (unit root) --> hence detrending can render our series stationary and we will test First Differences for stationarity, if this fails we will try higher order integrations to get a stationary series
- *IPI*: Looks non-stationary, determinisic trend (unit root) and additionally it seems like there is a structural break in our data at the financial crisis (2008 - 2009) [**Magnitude: sharp and much larger drop than usual, Persistence: no return to pre-crisis levels, Post-Break: Possibly new level and Trend**]
--> again here we will test for Integration of order 1 I(1) for stationarity
- *Credit Spread:* Look stationary only GFC break needs to be accounted for (othwise could fail stationarity tests) --> no differencin needed 


## Exercise 1.2: Conduct unit root and stationarity tests for each series

Given our previous results we propose to test the following unit root specifications: 

1) We will log CPI and IPI for two reasons, first trends here have a multiplicative relationship and not a linear one hence logarithm allows us to create a linear relationship which is necessary to apply AR, ARMA etc. (Linear Time Series Analysis to them)

2) Given that we already know we will apply at least 1 unit differences to get stationary results I(1) processes from our previous visual inspection of the data this gives us a nice feature for interpretation (e.g. we can interprete our log differences as growth rates *GIVE REASON HERE BRIEFLY*)

```{r exercise_1/2, include=FALSE}

## Exercise 1.2 Unit Root and Stationarity tests 

# 1. Take Logs and Δ log(.) of CPI and IPI for reasons described above ----

industrial <- industrial %>% 
  mutate(log_value = log(value))  %>% 
  mutate(dlog_value = log_value - lag(log_value)) %>%
  drop_na(dlog_value) # Drop first observation because of NA (othwerwise VARselect won't work)



cpi <- cpi %>% 
  mutate(log_value = log(value))  %>% 
  mutate(dlog_value = log_value - lag(log_value)) %>%
  drop_na(dlog_value) # Drop first observation because of NA (othwerwise VARselect won't work)

# Take FD for credit spreads --> No Log Transformation here 
credit_spread <- credit_spread %>%
  mutate(cs_d1= credit_spread$value - lag(credit_spread$value)) %>%
  drop_na(cs_d1)

# 1.2 Briefly look at plots of the Transformed Data 

plot(industrial$dlog_value) # no visible trend, fluctuates around constant mean close to 0 --> DRIFT 
plot(cpi$dlog_value) # more more volatile, no visible trend, fluctuates around constant around mean a bit > 0  --> DRIFT
plot(credit_spread$value) # fluctuation around constant mean 4-6 bps with a few dramatic spikes in crises 
plot(credit_spread$cs_d1) # look stationary around 0, with crisis outliers 

# 2. Unit Root tests ----

# 2.1 Use the VARS function to check the optimal # of lags ---- 
## Reminder: We are using monthly data so reasonable maximum lag order for monthly data is 12 months
# Use AIC for lag selection in ADF tests (Ng & Perron 2001 Lag Length Selection and the Construction of Unit Root Tests with Good Size and Power) 
# AIC better size and power for unit root tests 

VARselect(industrial$log_value, lag.max=12) #Result: AIC: 8 --> choose 7
VARselect(cpi$log_value, lag.max=12) #AIC 12 
VARselect(industrial$dlog_value, lag.max=12) #Result: AIC: 7 --> choose 7
VARselect(cpi$dlog_value, lag.max=12) #Result: consensus 12 lags 
VARselect(credit_spread$value, lag.max=12) # Result: AIC: 7  --> choose 7 Lags 
VARselect(credit_spread$cs_d1, lag.max = 12) # AIC: 6


## 2.1. Unit Root tests without Differentiation ---- 

### URCA - for unit root tests (w/o trends in the beginning only add trend if phi3: H0(trend=0)  —> reject)
### Remember use an appropriate maximum number of lags --> 12 for monthly data 
### We selected AIC lags anyway so we can let the function do this automatically and just give max # lags (12 for monthly)

# 1.1 Industrial Production (log‐level) with trend
adf_ip_lvl <- ur.df(industrial$log_value,
                    type       = "trend",
                    lags       = 12,
                    selectlags = "AIC")
summary(adf_ip_lvl)

pp_ip_lvl  <- ur.pp(industrial$log_value,
                    type   = "Z-tau", # trend
                    model  = "trend",
                    use.lag = 8)
summary(pp_ip_lvl)

kpss_ip_lvl <- kpss.test(industrial$log_value, null="Trend") # H0: trend stationarity 
print(kpss_ip_lvl)


# 1.2 CPI (log‐level) with trend
adf_cpi_lvl <- ur.df(cpi$log_value,
                     type       = "trend",
                     lags       = 12,
                     selectlags = "AIC")
summary(adf_cpi_lvl)

pp_cpi_lvl  <- ur.pp(cpi$log_value,
                     type   = "Z-tau", #trend
                     model  = "trend",
                     use.lag = 8)
summary(pp_cpi_lvl)

kpss_cpi_lvl <- kpss.test(cpi$log_value, null="Trend") #H0: trend stationarity
print(kpss_cpi_lvl)


# 1.3 Credit Spread (level) with drift
adf_cs_lvl <- ur.df(credit_spread$value,
                    type       = "drift",
                    lags       = 12,
                    selectlags = "AIC")
summary(adf_cs_lvl)

pp_cs_lvl  <- ur.pp(credit_spread$value,
                    type   = "Z-alpha", #no trend 
                    model  = "constant",
                    lags   = "short")
summary(pp_cs_lvl)

kpss_cs_lvl <- kpss.test(credit_spread$value, null="Level") #H0: level stationarity 
print(kpss_cs_lvl)

```


## Exercise 1.3: Identify and estimate candidate AR(p) and ARMA(p,q) models using the ACF and PACF. Which
model would you choose according to information criteria? Comment the results

```{r exercise_1/3, include=FALSE}


```

